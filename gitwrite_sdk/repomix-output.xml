This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  apiClient.ts
  index.ts
  types.ts
tests/
  apiClient.test.ts
.npmrc
jest.config.js
package.json
rollup.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/apiClient.ts">
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import {
  RepositoryBranchesResponse,
  RepositoryTagsResponse,
  RepositoryCommitsResponse,
  ListCommitsParams,
  SaveFileRequestPayload,
  SaveFileResponseData,
  // Multi-part upload types
  InputFile,
  FileMetadataForUpload,
  UploadInitiateRequestPayload,
  UploadInitiateResponseData,
  UploadCompleteRequestPayload,
  UploadCompleteResponseData,
  UploadURLData,
} from './types';

// Define a type for the token, which can be a string or null
export type AuthToken = string | null;

// (Optional) Define interfaces for login credentials and token response
// These might come from a dedicated types file or be defined here if simple
export interface LoginCredentials {
  username?: string; // Making username optional as per API's /token endpoint
  password?: string; // Making password optional as per API's /token endpoint
  // The API's /token endpoint uses form data (username, password),
  // so we'll construct FormData in the login method.
}

export interface TokenResponse {
  access_token: string;
  token_type: string;
}

export class GitWriteClient {
  private baseURL: string;
  private token: AuthToken = null;
  private axiosInstance: AxiosInstance;

  constructor(baseURL: string) {
    this.baseURL = baseURL.endsWith('/') ? baseURL.slice(0, -1) : baseURL;
    this.axiosInstance = axios.create({
      baseURL: this.baseURL,
    });
  }

  public setToken(token: string): void {
    this.token = token;
    this.updateAuthHeader();
  }

  public getToken(): AuthToken {
    return this.token;
  }

  public async login(credentials: LoginCredentials): Promise<TokenResponse> {
    const formData = new URLSearchParams();
    if (credentials.username) {
        formData.append('username', credentials.username);
    }
    if (credentials.password) {
        formData.append('password', credentials.password);
    }

    try {
      const response = await this.axiosInstance.post<TokenResponse>('/token', formData, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      });
      if (response.data.access_token) {
        this.setToken(response.data.access_token);
      }
      return response.data;
    } catch (error) {
      // console.error('Login failed:', error);
      throw error; // Re-throw to allow caller to handle
    }
  }

  public logout(): void {
    this.token = null;
    this.updateAuthHeader();
  }

  private updateAuthHeader(): void {
    if (this.token) {
      this.axiosInstance.defaults.headers.common['Authorization'] = `Bearer ${this.token}`;
    } else {
      delete this.axiosInstance.defaults.headers.common['Authorization'];
    }
  }

  // Generic request method
  public async request<T = any, R = AxiosResponse<T>, D = any>(config: AxiosRequestConfig<D>): Promise<R> {
    try {
      // The token is already set in the axiosInstance defaults by updateAuthHeader
      // So, no need to manually add it here for each request.
      const response = await this.axiosInstance.request<T, R, D>(config);
      return response;
    } catch (error) {
      // Basic error logging, can be expanded
      // console.error(`API request to ${config.url} failed:`, error);
      // It's often better to let the caller handle the error,
      // or transform it into a more specific error type.
      throw error;
    }
  }

  // Example of a GET request using the generic method
  public async get<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R> {
    return this.request<T, R, D>({ ...config, method: 'GET', url });
  }

  // Example of a POST request
  public async post<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R> {
    return this.request<T, R, D>({ ...config, method: 'POST', url, data });
  }

  // Example of a PUT request
  public async put<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R> {
    return this.request<T, R, D>({ ...config, method: 'PUT', url, data });
  }

  // Example of a DELETE request
  public async delete<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R> {
    return this.request<T, R, D>({ ...config, method: 'DELETE', url });
  }

  // Repository Methods

  /**
   * Lists all local branches in the repository.
   * Corresponds to API endpoint: GET /repository/branches
   */
  public async listBranches(): Promise<RepositoryBranchesResponse> {
    // The actual response object from Axios is AxiosResponse<RepositoryBranchesResponse>
    // We are interested in the `data` part of it.
    const response = await this.get<RepositoryBranchesResponse>('/repository/branches');
    return response.data;
  }

  /**
   * Lists all tags in the repository.
   * Corresponds to API endpoint: GET /repository/tags
   */
  public async listTags(): Promise<RepositoryTagsResponse> {
    const response = await this.get<RepositoryTagsResponse>('/repository/tags');
    return response.data;
  }

  /**
   * Lists commits for a given branch, or the current branch if branch_name is not provided.
   * Corresponds to API endpoint: GET /repository/commits
   * @param params Optional parameters: branchName, maxCount.
   */
  public async listCommits(params?: ListCommitsParams): Promise<RepositoryCommitsResponse> {
    const queryParams: Record<string, string | number> = {};
    if (params?.branchName) {
      queryParams['branch_name'] = params.branchName;
    }
    if (params?.maxCount !== undefined) {
      queryParams['max_count'] = params.maxCount;
    }

    const response = await this.get<RepositoryCommitsResponse>('/repository/commits', {
      params: queryParams,
    });
    return response.data;
  }

  /**
   * Saves a file to the repository and commits the change.
   * Corresponds to API endpoint: POST /repository/save
   * @param filePath The relative path of the file in the repository.
   * @param content The content to be saved to the file.
   * @param commitMessage The commit message for the save operation.
   */
  public async save(filePath: string, content: string, commitMessage: string): Promise<SaveFileResponseData> {
    const payload: SaveFileRequestPayload = {
      file_path: filePath,
      content: content,
      commit_message: commitMessage,
    };
    const response = await this.post<SaveFileResponseData, AxiosResponse<SaveFileResponseData>, SaveFileRequestPayload>(
      '/repository/save',
      payload
    );
    return response.data;
  }

  /**
   * Saves multiple files to the repository using a multi-part upload process.
   * Handles initiating the upload, uploading individual files, and completing the upload.
   * @param repoId The ID of the repository.
   * @param files An array of InputFile objects, each with a path and content (Blob or Buffer).
   * @param commitMessage The commit message for the save operation.
   * @returns A promise that resolves with the response from the complete upload endpoint.
   */
  public async saveFiles(
    repoId: string,
    files: InputFile[],
    commitMessage: string
  ): Promise<UploadCompleteResponseData> {
    // Step 1: Prepare metadata and call /initiate endpoint
    const filesMetadata: FileMetadataForUpload[] = files.map(file => ({
      file_path: file.path,
      size: file.size ?? (file.content instanceof Blob ? file.content.size : Buffer.byteLength(file.content)),
      // hash: file.hash, // If hash calculation is implemented
    }));

    const initiatePayload: UploadInitiateRequestPayload = {
      files: filesMetadata,
      commit_message: commitMessage,
    };

    const initiateResponse = await this.post<UploadInitiateResponseData, AxiosResponse<UploadInitiateResponseData>, UploadInitiateRequestPayload>(
      `/repositories/${repoId}/save/initiate`,
      initiatePayload
    );

    const { completion_token, files: uploadInstructions } = initiateResponse.data;

    if (!completion_token || !uploadInstructions || uploadInstructions.length === 0) {
      throw new Error('Invalid response from initiate upload endpoint.');
    }

    // Step 2: Upload individual files in parallel
    const uploadPromises = uploadInstructions.map(async (instruction: UploadURLData) => {
      const fileToUpload = files.find(f => f.path === instruction.file_path);
      if (!fileToUpload) {
        throw new Error(`File data not found for path: ${instruction.file_path}`);
      }

      // The instruction.upload_url is expected to be a relative path like /upload-session/{upload_id}
      // Axios will prepend the baseURL to this.
      await this.put<any, AxiosResponse<any>, Blob | Buffer>(
        instruction.upload_url,
        fileToUpload.content,
        {
          headers: {
            // Axios typically sets Content-Type automatically for Blob/Buffer,
            // but being explicit for application/octet-stream can be good.
            'Content-Type': 'application/octet-stream',
          },
        }
      );
    });

    await Promise.all(uploadPromises);

    // Step 3: Call /complete endpoint
    const completePayload: UploadCompleteRequestPayload = {
      completion_token: completion_token,
    };

    const completeResponse = await this.post<UploadCompleteResponseData, AxiosResponse<UploadCompleteResponseData>, UploadCompleteRequestPayload>(
      `/repositories/${repoId}/save/complete`,
      completePayload
    );

    return completeResponse.data;
  }
}

// Example usage (optional, for testing within this file)
/*
async function main() {
  const client = new GitWriteClient('http://localhost:8000/api/v1'); // Replace with your API base URL

  try {
    // Login
    // Note: The default /token endpoint from FastAPI's OAuth2PasswordBearer expects
    // 'username' and 'password' as form data, not JSON.
    // The API's /token endpoint is currently set up with a dummy user if no credentials are provided.
    // For a real scenario, you'd pass actual credentials.
    const tokenData = await client.login({});
    console.log('Login successful:', tokenData);
    console.log('Token from client:', client.getToken());

    // Example: Make an authenticated GET request (replace with an actual endpoint)
    // const someData = await client.get('/users/me'); // Assuming such an endpoint exists
    // console.log('Fetched data:', someData.data);

    // Logout
    client.logout();
    console.log('Logged out. Token:', client.getToken());

  } catch (error) {
    if (axios.isAxiosError(error)) {
      console.error('API Error:', error.response?.data || error.message);
    } else {
      console.error('An unexpected error occurred:', error);
    }
  }
}

// main(); // Uncomment to run example
*/
</file>

<file path="src/index.ts">
// SDK entry point
export { GitWriteClient, type AuthToken, type LoginCredentials, type TokenResponse } from './apiClient';

// Export types related to repository operations
export type {
  Branch,
  Tag,
  CommitDetail,
  RepositoryBranchesResponse,
  RepositoryTagsResponse,
  RepositoryCommitsResponse,
  ListCommitsParams,
  ApiErrorResponse,
  SaveFileRequestPayload,
  SaveFileResponseData,
  // Multi-Part Upload Types
  InputFile,
  FileMetadataForUpload,
  UploadInitiateRequestPayload,
  UploadURLData,
  UploadInitiateResponseData,
  UploadCompleteRequestPayload,
  UploadCompleteResponseData,
} from './types';

// You can also export other modules or types here as the SDK grows
// For example:
// export * from './repository';
</file>

<file path="src/types.ts">
// src/types.ts

/**
 * Represents a single Git branch.
 */
export interface Branch {
  name: string; // Assuming the API returns a list of names directly
}

/**
 * Represents a single Git tag.
 */
export interface Tag {
  name: string; // Assuming the API returns a list of names directly
}

/**
 * Represents detailed information about a Git commit.
 * Based on `CommitDetail` Pydantic model in the API.
 */
export interface CommitDetail {
  sha: string;
  message: string;
  author_name: string;
  author_email: string;
  author_date: string; // ISO 8601 date string or number (timestamp)
  committer_name: string;
  committer_email: string;
  committer_date: string; // ISO 8601 date string or number (timestamp)
  parents: string[];
}

/**
 * Represents the API response for listing branches.
 * Based on `BranchListResponse` Pydantic model.
 */
export interface RepositoryBranchesResponse {
  status: string;
  branches: string[]; // The API model has `List[str]` for branches
  message: string;
}

/**
 * Represents the API response for listing tags.
 * Based on `TagListResponse` Pydantic model.
 */
export interface RepositoryTagsResponse {
  status: string;
  tags: string[]; // The API model has `List[str]` for tags
  message: string;
}

/**
 * Represents the API response for listing commits.
 * Based on `CommitListResponse` Pydantic model.
 */
export interface RepositoryCommitsResponse {
  status: string;
  commits: CommitDetail[];
  message: string;
}

/**
 * Represents parameters for listing commits.
 */
export interface ListCommitsParams {
  branchName?: string;
  maxCount?: number;
}

// General API error structure, if common
export interface ApiErrorResponse {
  detail?: string | { msg: string; type: string }[]; // FastAPI error format
}

/**
 * Represents the payload for the save file request.
 * Based on `SaveFileRequest` Pydantic model in the API.
 */
export interface SaveFileRequestPayload {
  file_path: string;
  content: string;
  commit_message: string;
}

/**
 * Represents the response data for the save file operation.
 * Based on `SaveFileResponse` Pydantic model in the API.
 */
export interface SaveFileResponseData {
  status: string;
  message: string;
  commit_id?: string; // Optional, as it might not be present on error
}

// Interfaces for Multi-Part Upload (Task 6.5)

/**
 * Represents a file to be uploaded as part of a multi-file save operation.
 * Content can be Blob (for browser environments) or Buffer (for Node.js).
 */
export interface InputFile {
  path: string;
  content: Blob | Buffer; // Using Blob for browser, Buffer for Node.js
  size?: number; // Optional: size of the content in bytes
  // hash?: string; // Optional: SHA256 hash of the content, if pre-calculated
}

/**
 * Represents metadata for a single file in the upload initiation request.
 * This aligns with the API's expected `FileMetadata` Pydantic model.
 */
export interface FileMetadataForUpload {
  file_path: string;
  size?: number; // Optional: size of the content in bytes
  // hash?: string; // Optional: SHA256 hash of the content
}

/**
 * Represents the payload for initiating a multi-part upload.
 * Aligns with API's `FileUploadInitiateRequest` Pydantic model.
 */
export interface UploadInitiateRequestPayload {
  // repo_id is part of the URL path: /repositories/{repo_id}/save/initiate
  // The body should match the Pydantic model FileUploadInitiateRequest
  files: FileMetadataForUpload[];
  commit_message: string;
}

/**
 * Represents the data for a single file's upload URL and ID, received from the initiate response.
 */
export interface UploadURLData {
  file_path: string;
  upload_url: string; // This will be the relative path like /upload-session/{upload_id}
  upload_id: string;  // The unique ID for this specific file upload session
}

/**
 * Represents the response from the multi-part upload initiation endpoint.
 * Aligns with API's `FileUploadInitiateResponse` Pydantic model.
 */
export interface UploadInitiateResponseData {
  status: string;
  message: string;
  completion_token: string;
  files: UploadURLData[]; // Details for each file to be uploaded
}

/**
 * Represents the payload for completing a multi-part upload.
 * Aligns with API's `FileUploadCompleteRequest` Pydantic model.
 */
export interface UploadCompleteRequestPayload {
  completion_token: string;
}

/**
 * Represents the response from the multi-part upload completion endpoint.
 * Aligns with API's `FileUploadCompleteResponse` Pydantic model.
 */
export interface UploadCompleteResponseData {
  status: string;
  message: string;
  commit_id?: string; // Optional, as it might not be present on error
}
</file>

<file path="tests/apiClient.test.ts">
import axios from 'axios';
import { GitWriteClient, LoginCredentials, TokenResponse } from '../src/apiClient';
import {
  RepositoryBranchesResponse,
  RepositoryTagsResponse,
  RepositoryCommitsResponse,
  CommitDetail,
  ListCommitsParams,
  SaveFileRequestPayload,
  SaveFileResponseData,
  // Multi-part upload types for testing
  InputFile,
  UploadInitiateRequestPayload,
  UploadInitiateResponseData,
  UploadCompleteRequestPayload,
  UploadCompleteResponseData,
  UploadURLData,
  FileMetadataForUpload,
} from '../src/types';

// Mock axios
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

// Mock the axios instance methods
const mockPost = jest.fn();
const mockGet = jest.fn();
const mockPut = jest.fn();
const mockDelete = jest.fn();
const mockRequest = jest.fn(); // Added for the generic request method

describe('GitWriteClient', () => {
  const baseURL = 'http://localhost:8000/api/v1';
  let client: GitWriteClient;
  let clientAxiosInstance: any; // To store the instance used by the client for easier access in tests

  beforeEach(() => {
    // Reset all mocks before each test
    mockPost.mockClear();
    mockGet.mockClear();
    mockPut.mockClear();
    mockDelete.mockClear();
    mockRequest.mockClear();

    // This is the instance that the GitWriteClient will use
    clientAxiosInstance = {
      post: mockPost,
      get: mockGet, // Kept for direct client.axiosInstance.get if ever used, but request is primary
      put: mockPut,
      delete: mockDelete,
      request: mockRequest, // This is the one GitWriteClient.request method will call
      defaults: { headers: { common: {} } },
      interceptors: {
        request: { use: jest.fn(), eject: jest.fn() },
        response: { use: jest.fn(), eject: jest.fn() },
      },
    };

    mockedAxios.create.mockReturnValue(clientAxiosInstance);

    client = new GitWriteClient(baseURL);

    mockedAxios.isAxiosError.mockImplementation((payload: any): payload is import('axios').AxiosError => {
        return payload instanceof Error && 'isAxiosError' in payload && payload.isAxiosError === true;
    });
  });

  describe('constructor', () => {
    it('should initialize baseURL correctly and create an axios instance', () => {
      expect(mockedAxios.create).toHaveBeenCalledWith({ baseURL });
    });

    it('should remove trailing slash from baseURL', () => {
      const clientWithSlash = new GitWriteClient('http://localhost:8000/api/v1/');
      // The client instance is created in beforeEach, so we check the last call
      expect(mockedAxios.create).toHaveBeenCalledWith({ baseURL: 'http://localhost:8000/api/v1' });
    });
  });

  describe('login', () => {
    it('should make a POST request to /token with credentials and store the token', async () => {
      const credentials: LoginCredentials = { username: 'testuser', password: 'password' };
      const tokenResponse: TokenResponse = { access_token: 'fake-token', token_type: 'bearer' };

      // mockPost is part of clientAxiosInstance, which is what client.login will use
      mockPost.mockResolvedValueOnce({ data: tokenResponse });

      const response = await client.login(credentials);

      expect(response).toEqual(tokenResponse);
      expect(mockPost).toHaveBeenCalledWith(
        '/token',
        expect.any(URLSearchParams),
        { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
      );

      const calledParams = mockPost.mock.calls[0][1] as URLSearchParams;
      expect(calledParams.get('username')).toBe('testuser');
      expect(calledParams.get('password')).toBe('password');

      expect(client.getToken()).toBe('fake-token');
      // Check Authorization header on the *client's actual axios instance*
      expect(clientAxiosInstance.defaults.headers.common['Authorization']).toBe('Bearer fake-token');
    });

    it('should handle login failure', async () => {
      const credentials: LoginCredentials = { username: 'testuser', password: 'password' };
      const error = new Error('Login failed');
      (error as any).isAxiosError = true;
      (error as any).response = { data: 'Invalid credentials' };

      mockPost.mockRejectedValueOnce(error);

      await expect(client.login(credentials)).rejects.toThrow('Login failed');
      expect(client.getToken()).toBeNull();
      expect(clientAxiosInstance.defaults.headers.common['Authorization']).toBeUndefined();
    });

    it('should make a POST request to /token without credentials if none provided', async () => {
      const tokenResponse: TokenResponse = { access_token: 'guest-token', token_type: 'bearer' };
      mockPost.mockResolvedValueOnce({ data: tokenResponse });

      await client.login({});

      const calledParams = mockPost.mock.calls[0][1] as URLSearchParams;
      expect(calledParams.has('username')).toBe(false);
      expect(calledParams.has('password')).toBe(false);
      expect(client.getToken()).toBe('guest-token');
      expect(clientAxiosInstance.defaults.headers.common['Authorization']).toBe('Bearer guest-token');
    });
  });

  describe('setToken', () => {
    it('should store the token and update axios instance headers', () => {
      const token = 'manual-token';
      client.setToken(token);
      expect(client.getToken()).toBe(token);
      expect(clientAxiosInstance.defaults.headers.common['Authorization']).toBe(`Bearer ${token}`);
    });
  });

  describe('logout', () => {
    it('should clear the token and remove Authorization header', () => {
      client.setToken('some-token');
      expect(client.getToken()).toBe('some-token');
      expect(clientAxiosInstance.defaults.headers.common['Authorization']).toBe('Bearer some-token');

      client.logout();

      expect(client.getToken()).toBeNull();
      expect(clientAxiosInstance.defaults.headers.common['Authorization']).toBeUndefined();
    });
  });

  describe('request method (via get, post, put, delete helpers)', () => {
    beforeEach(() => {
      client.setToken('test-token');
      // This ensures clientAxiosInstance.defaults.headers.common['Authorization'] is set
      // before each request test, as GitWriteClient.request relies on it.
    });

    it('GET request should be made with correct parameters', async () => {
      mockRequest.mockResolvedValueOnce({ data: { message: 'success' } });
      const response = await client.get('/test-get');

      expect(mockRequest).toHaveBeenCalledWith({ method: 'GET', url: '/test-get' });
      expect(response.data).toEqual({ message: 'success' });
      // Authorization header is managed by client.setToken -> updateAuthHeader
      // and is part of clientAxiosInstance.defaults.headers.common
      expect(clientAxiosInstance.defaults.headers.common['Authorization']).toBe('Bearer test-token');
    });

    it('POST request should be made with correct parameters and data', async () => {
      const postData = { key: 'value' };
      mockRequest.mockResolvedValueOnce({ data: { id: 1, ...postData } });
      const response = await client.post('/test-post', postData);

      expect(mockRequest).toHaveBeenCalledWith({ method: 'POST', url: '/test-post', data: postData });
      expect(response.data).toEqual({ id: 1, ...postData });
      expect(clientAxiosInstance.defaults.headers.common['Authorization']).toBe('Bearer test-token');
    });

    it('PUT request should be made with correct parameters and data', async () => {
      const putData = { key: 'updatedValue' };
      mockRequest.mockResolvedValueOnce({ data: { ...putData } });
      const response = await client.put('/test-put/1', putData);

      expect(mockRequest).toHaveBeenCalledWith({ method: 'PUT', url: '/test-put/1', data: putData });
      expect(response.data).toEqual({ ...putData });
    });

    it('DELETE request should be made with correct parameters', async () => {
      mockRequest.mockResolvedValueOnce({ status: 204 });
      const response = await client.delete('/test-delete/1');

      expect(mockRequest).toHaveBeenCalledWith({ method: 'DELETE', url: '/test-delete/1' });
      expect(response.status).toBe(204);
    });

    it('should throw error if request fails', async () => {
      const error = new Error('Network Error');
      (error as any).isAxiosError = true;
      (error as any).response = { status: 500, data: 'Server Error' };

      mockRequest.mockRejectedValueOnce(error); // Mocking the generic request method
      await expect(client.get('/test-error')).rejects.toThrow('Network Error');

      // Reset mock for next call if necessary, or use different error for POST
      mockRequest.mockRejectedValueOnce(new Error('Another Network Error'));
      await expect(client.post('/test-error-post', {})).rejects.toThrow('Another Network Error');
    });
  });

  describe('Repository Methods', () => {
    beforeEach(() => {
      // Ensure client is authenticated for these tests
      client.setToken('test-repo-token');
      // clientAxiosInstance.defaults.headers.common['Authorization'] is set by setToken
    });

    describe('listBranches', () => {
      it('should call GET /repository/branches and return data', async () => {
        const mockResponseData: RepositoryBranchesResponse = {
          status: 'success',
          branches: ['main', 'develop'],
          message: 'Branches listed',
        };
        // The client.get method uses clientAxiosInstance.request
        mockRequest.mockResolvedValueOnce({ data: mockResponseData });

        const result = await client.listBranches();

        expect(mockRequest).toHaveBeenCalledWith({
          method: 'GET',
          url: '/repository/branches',
        });
        expect(result).toEqual(mockResponseData);
      });

      it('should throw if API call fails for listBranches', async () => {
        const error = new Error('API Error for listBranches');
        mockRequest.mockRejectedValueOnce(error);
        await expect(client.listBranches()).rejects.toThrow('API Error for listBranches');
      });
    });

    describe('listTags', () => {
      it('should call GET /repository/tags and return data', async () => {
        const mockResponseData: RepositoryTagsResponse = {
          status: 'success',
          tags: ['v1.0', 'v1.1'],
          message: 'Tags listed',
        };
        mockRequest.mockResolvedValueOnce({ data: mockResponseData });

        const result = await client.listTags();

        expect(mockRequest).toHaveBeenCalledWith({
          method: 'GET',
          url: '/repository/tags',
        });
        expect(result).toEqual(mockResponseData);
      });

      it('should throw if API call fails for listTags', async () => {
        const error = new Error('API Error for listTags');
        mockRequest.mockRejectedValueOnce(error);
        await expect(client.listTags()).rejects.toThrow('API Error for listTags');
      });
    });

    describe('listCommits', () => {
      const mockCommit: CommitDetail = {
        sha: 'abcdef123',
        message: 'Test commit',
        author_name: 'Test Author',
        author_email: 'author@example.com',
        author_date: new Date().toISOString(),
        committer_name: 'Test Committer',
        committer_email: 'committer@example.com',
        committer_date: new Date().toISOString(),
        parents: [],
      };
      const mockResponseData: RepositoryCommitsResponse = {
        status: 'success',
        commits: [mockCommit],
        message: 'Commits listed',
      };

      it('should call GET /repository/commits without params and return data', async () => {
        mockRequest.mockResolvedValueOnce({ data: mockResponseData });
        const result = await client.listCommits();
        expect(mockRequest).toHaveBeenCalledWith({
          method: 'GET',
          url: '/repository/commits',
          params: {}, // Expect empty params when none provided
        });
        expect(result).toEqual(mockResponseData);
      });

      it('should call GET /repository/commits with branchName param', async () => {
        const params: ListCommitsParams = { branchName: 'develop' };
        mockRequest.mockResolvedValueOnce({ data: mockResponseData });
        await client.listCommits(params);
        expect(mockRequest).toHaveBeenCalledWith({
          method: 'GET',
          url: '/repository/commits',
          params: { branch_name: 'develop' },
        });
      });

      it('should call GET /repository/commits with maxCount param', async () => {
        const params: ListCommitsParams = { maxCount: 10 };
        mockRequest.mockResolvedValueOnce({ data: mockResponseData });
        await client.listCommits(params);
        expect(mockRequest).toHaveBeenCalledWith({
          method: 'GET',
          url: '/repository/commits',
          params: { max_count: 10 },
        });
      });

      it('should call GET /repository/commits with all params', async () => {
        const params: ListCommitsParams = { branchName: 'feature/test', maxCount: 5 };
        mockRequest.mockResolvedValueOnce({ data: mockResponseData });
        await client.listCommits(params);
        expect(mockRequest).toHaveBeenCalledWith({
          method: 'GET',
          url: '/repository/commits',
          params: { branch_name: 'feature/test', max_count: 5 },
        });
      });

      it('should throw if API call fails for listCommits', async () => {
        const error = new Error('API Error for listCommits');
        mockRequest.mockRejectedValueOnce(error);
        await expect(client.listCommits()).rejects.toThrow('API Error for listCommits');
      });
    });

    describe('save', () => {
      const filePath = 'test.txt';
      const content = 'Hello, world!';
      const commitMessage = 'Add test.txt';

      const mockRequestPayload: SaveFileRequestPayload = {
        file_path: filePath,
        content: content,
        commit_message: commitMessage,
      };

      it('should call POST /repository/save with correct payload and return data', async () => {
        const mockResponseData: SaveFileResponseData = {
          status: 'success',
          message: 'File saved successfully',
          commit_id: 'newcommitsha123',
        };
        // The client.post method uses clientAxiosInstance.request
        mockRequest.mockResolvedValueOnce({ data: mockResponseData });

        const result = await client.save(filePath, content, commitMessage);

        expect(mockRequest).toHaveBeenCalledWith({
          method: 'POST',
          url: '/repository/save',
          data: mockRequestPayload,
        });
        expect(result).toEqual(mockResponseData);
      });

      it('should throw if API call fails for save', async () => {
        const error = new Error('API Error for save');
        mockRequest.mockRejectedValueOnce(error);

        await expect(client.save(filePath, content, commitMessage)).rejects.toThrow('API Error for save');
        expect(mockRequest).toHaveBeenCalledWith({
          method: 'POST',
          url: '/repository/save',
          data: mockRequestPayload,
        });
      });
    });
  });

  describe('saveFiles (Multi-Part Upload)', () => {
    const repoId = 'test-repo';
    const commitMessage = 'Test multi-file commit';
    const file1Content = Buffer.from('Content for file 1');
    const file2Content = Buffer.from('Content for file 2');

    const inputFiles: InputFile[] = [
      { path: 'file1.txt', content: file1Content, size: file1Content.length },
      { path: 'path/to/file2.md', content: file2Content, size: file2Content.length },
    ];

    const mockFilesMetadata: FileMetadataForUpload[] = inputFiles.map(f => ({
        file_path: f.path,
        size: f.size,
    }));

    const mockInitiatePayload: UploadInitiateRequestPayload = {
      files: mockFilesMetadata,
      commit_message: commitMessage,
    };

    const mockUploadURLs: UploadURLData[] = [
      { file_path: 'file1.txt', upload_url: '/upload-session/upload-id-1', upload_id: 'upload-id-1' },
      { file_path: 'path/to/file2.md', upload_url: '/upload-session/upload-id-2', upload_id: 'upload-id-2' },
    ];

    const mockInitiateResponse: UploadInitiateResponseData = {
      status: 'success',
      message: 'Upload initiated',
      completion_token: 'test-completion-token',
      files: mockUploadURLs,
    };

    const mockCompletePayload: UploadCompleteRequestPayload = {
      completion_token: 'test-completion-token',
    };

    const mockCompleteResponse: UploadCompleteResponseData = {
      status: 'success',
      message: 'Files saved successfully',
      commit_id: 'multi-commit-sha456',
    };

    beforeEach(() => {
      // Ensure client is authenticated
      client.setToken('test-savefiles-token');
    });

    it('should successfully perform a multi-part upload', async () => {
      // Mock /initiate call (uses client.post -> client.request)
      mockRequest
        .mockResolvedValueOnce({ data: mockInitiateResponse }); // For initiate POST

      // Mock individual file PUT uploads (uses client.put -> client.request)
      // Two files, so two PUT calls
      mockRequest.mockResolvedValueOnce({ status: 200, data: { message: 'upload 1 ok'} }); // For file1.txt PUT
      mockRequest.mockResolvedValueOnce({ status: 200, data: { message: 'upload 2 ok'} }); // For file2.md PUT

      // Mock /complete call (uses client.post -> client.request)
      mockRequest.mockResolvedValueOnce({ data: mockCompleteResponse }); // For complete POST

      const result = await client.saveFiles(repoId, inputFiles, commitMessage);

      // Verify /initiate call
      expect(mockRequest).toHaveBeenNthCalledWith(1, {
        method: 'POST',
        url: `/repositories/${repoId}/save/initiate`,
        data: mockInitiatePayload,
      });

      // Verify PUT calls for file uploads
      // Order of Promise.all execution isn't strictly guaranteed for map,
      // so check for both calls regardless of order if necessary, or ensure mock setup matches expected call order.
      // For simplicity here, assuming they are called in order of mockRequest setup.
      expect(mockRequest).toHaveBeenNthCalledWith(2, {
        method: 'PUT',
        url: mockUploadURLs[0].upload_url, // /upload-session/upload-id-1
        data: inputFiles[0].content,
        headers: { 'Content-Type': 'application/octet-stream' },
      });
      expect(mockRequest).toHaveBeenNthCalledWith(3, {
        method: 'PUT',
        url: mockUploadURLs[1].upload_url, // /upload-session/upload-id-2
        data: inputFiles[1].content,
        headers: { 'Content-Type': 'application/octet-stream' },
      });

      // Verify /complete call
      expect(mockRequest).toHaveBeenNthCalledWith(4, {
        method: 'POST',
        url: `/repositories/${repoId}/save/complete`,
        data: mockCompletePayload,
      });

      expect(result).toEqual(mockCompleteResponse);
    });

    it('should throw an error if /initiate call fails', async () => {
      const initiateError = new Error('Initiate failed');
      mockRequest.mockRejectedValueOnce(initiateError); // For initiate POST

      await expect(client.saveFiles(repoId, inputFiles, commitMessage)).rejects.toThrow('Initiate failed');
      expect(mockRequest).toHaveBeenCalledTimes(1); // Only initiate should be called
    });

    it('should throw an error if any file upload (PUT) fails', async () => {
      mockRequest.mockResolvedValueOnce({ data: mockInitiateResponse }); // Initiate POST succeeds

      const uploadError = new Error('Upload failed for file1.txt');
      mockRequest.mockRejectedValueOnce(uploadError); // First PUT fails
      // No need to mock the second PUT if the first one throws and Promise.all rejects

      await expect(client.saveFiles(repoId, inputFiles, commitMessage)).rejects.toThrow('Upload failed for file1.txt');

      expect(mockRequest).toHaveBeenCalledTimes(2); // Initiate + 1st PUT
      // (Could be 3 if Promise.all allows other promises to start, but one rejection is enough)
    });

    it('should throw an error if /complete call fails', async () => {
      mockRequest.mockResolvedValueOnce({ data: mockInitiateResponse }); // Initiate POST
      mockRequest.mockResolvedValueOnce({ status: 200 }); // File 1 PUT
      mockRequest.mockResolvedValueOnce({ status: 200 }); // File 2 PUT

      const completeError = new Error('Complete failed');
      mockRequest.mockRejectedValueOnce(completeError); // Complete POST fails

      await expect(client.saveFiles(repoId, inputFiles, commitMessage)).rejects.toThrow('Complete failed');
      expect(mockRequest).toHaveBeenCalledTimes(4); // Initiate + 2 PUTs + Complete
    });

    it('should throw an error if initiate response is invalid (no token)', async () => {
        const invalidInitiateResponse = { ...mockInitiateResponse, completion_token: '' };
        mockRequest.mockResolvedValueOnce({ data: invalidInitiateResponse });

        await expect(client.saveFiles(repoId, inputFiles, commitMessage)).rejects.toThrow('Invalid response from initiate upload endpoint.');
        expect(mockRequest).toHaveBeenCalledTimes(1);
    });

    it('should throw an error if file data is not found for an upload instruction', async () => {
        const modifiedUploadURLs = [
            { file_path: 'nonexistent.txt', upload_url: '/upload-session/upload-id-x', upload_id: 'upload-id-x' }
        ];
        const initiateResponseWithBadFile = { ...mockInitiateResponse, files: modifiedUploadURLs };
        mockRequest.mockResolvedValueOnce({ data: initiateResponseWithBadFile }); // Initiate succeeds

        await expect(client.saveFiles(repoId, inputFiles, commitMessage)).rejects.toThrow('File data not found for path: nonexistent.txt');
        expect(mockRequest).toHaveBeenCalledTimes(1); // Only initiate call
    });
  });
});
</file>

<file path=".npmrc">
registry=https://registry.npmjs.org
</file>

<file path="jest.config.js">
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  // Jest will search from the root directory of the project (where jest.config.js is)
  // The default testMatch should pick up .test.ts files.
};
</file>

<file path="package.json">
{
  "name": "gitwrite-sdk",
  "version": "0.1.0",
  "description": "TypeScript SDK for the GitWrite API",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/types/index.d.ts",
  "scripts": {
    "test": "jest",
    "build": "rollup -c",
    "prepack": "npm run build"
  },
  "keywords": [
    "git",
    "writing",
    "version-control"
  ],
  "author": "GitWrite Team",
  "license": "MIT",
  "dependencies": {
    "@rollup/plugin-typescript": "^12.1.3",
    "@types/jest": "^30.0.0",
    "axios": "^1.10.0",
    "jest": "^30.0.2",
    "rollup": "^4.44.0",
    "rollup-plugin-dts": "^6.2.1",
    "ts-jest": "^29.4.0",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="rollup.config.js">
import typescript from '@rollup/plugin-typescript';
import { dts } from 'rollup-plugin-dts';

export default [
  {
    input: 'src/index.ts',
    output: [
      {
        file: 'dist/cjs/index.js',
        format: 'cjs',
        sourcemap: true,
      },
      {
        file: 'dist/esm/index.js',
        format: 'esm',
        sourcemap: true,
      },
    ],
    plugins: [typescript()],
  },
  {
    input: 'src/index.ts',
    output: [{ file: 'dist/types/index.d.ts', format: 'es' }],
    plugins: [dts()],
  },
];
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM"],
    "declaration": true,
    "declarationDir": "dist/types",
    "outDir": "dist",
    "strict": true,
    "moduleResolution": "node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "sourceMap": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
</file>

</files>
